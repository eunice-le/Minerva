###QUESTION 1
###Part (a)
sesame <- read.csv("https://tinyurl.com/wlgl63b")
head(sesame)
#Separate treatment group from control group
which.treat <- which(sesame$treatment== 1)
which.control <- which(sesame$treatment == 0)
sesame.treat <- sesame[-which.control,]
sesame.control <- sesame[-which.treat,]

#linear regression of pre.test and post.test for treatment group and control group
lm.treat <- lm(post.test~pre.test, sesame.treat)
lm.control <- lm(post.test~pre.test, sesame.control)
lm.treat
lm.control

#plotting the regression
#Treatment group: circle, control group: black dot
#Treatment group regression line: solid, Control group regression line: dash
plot(x = sesame$pre.test, y = sesame$post.test,
      xlim = c(0,120), ylim = c(0,120),
      pch = ifelse(sesame$treatment == 1, 1, 16),
      main = "Grade 4",
      xlab = "Pre-test", 
      ylab = "Post-test")
abline(lm.treat,
       col = "black")
abline(lm.control,
       col = "black",
       lty = 2)

###Part (b)
#Set up a new data set for modification 
sesame.b <- read.csv("https://tinyurl.com/wlgl63b")
sesame.b$post.test[c(11)]<-75
#Separate treatment from control groups
which.treat.b <- which(sesame.b$treatment== 1)
which.control.b <- which(sesame.b$treatment == 0)
sesame.treat.b <- sesame.b[-which.control,]
sesame.control.b <- sesame.b[-which.treat,]

#Linear regression between pre.test and post.test 
lm.treat.b <- lm(post.test ~ pre.test, sesame.treat.b)
lm.control.b <- lm(post.test ~ pre.test, sesame.control.b)
lm.treat.b
lm.control.b

#Plotting the regression 
plot(x = sesame.b$pre.test, y = sesame.b$post.test,
     xlim = c(0,120), ylim = c(0,120),
     pch = ifelse(sesame.b$treatment == 1, 1, 16),
     col = ifelse(sesame.b$post.test == 75, "red", "black"),
     main = "Grade 4",
     xlab = "Pre-test", 
     ylab = "Post-test")
abline(lm.treat.b,
       col = "black")
abline(lm.control.b,
       col = "black",
       lty = 2)

###Part (c)
lm.4 <- lm(post.test ~ treatment + pre.test + treatment:pre.test, sesame)
summary(lm.4)
lm.4.sim <- sim(lm.4)
lm.4.sim
plot(0, 0, xlim=range(sesame$pre.test), ylim=c(-5,10),
      xlab="pre-test", ylab="treatment effect",
      main="treatment effect in grade 4")
abline(0, 0, lwd=.5, lty=2)
for(i in 1:20){
  abline(a = coef(lm.4.sim)[i,2], b = coef(lm.4.sim)[i,4],
          lwd = .5, col = "gray")}
abline(a = mean(coef(lm.4.sim)[,2]),
        b = mean(coef(lm.4.sim)[,4]),
        lwd = 1, col = "black")


###QUESTION 2
#Preparing the dataset 
tinting = read.csv(url("https://tinyurl.com/v4bq99k"))
head(tinting)

###Part (a)
set.seed(12)
#Linear regression model predicting "csoa"
lm.tint <- lm(csoa ~ age + sex + target + I(tint != "no") + I(as.numeric(tint!= "no")*age), tinting)
#Identify what dummy variables are used for sex and target tint in the lm.tint regression model 
contrasts(tinting$sex) #f = 0, m = 1 
contrasts(tinting$target) #hicon = 0, locon = 1 

#Generate 1000 simulations to predict csoa 
sim.tint <- sim(lm.tint, n.sims = 1000)

#assign the ages for which we want to predict "csoa" to a vector
age.values <- c(20,30,40,50,60,70,80)
simulated <- matrix(NA, nrow = 1000, ncol = length(age.values))

#Using "for" loop to predict "csoa" for every Treated Female units, target = "hicon", ages = 20,30,..80
#female == 0, hicon == 0, treated units: I(tint!= "no") == TRUE
for (i in 1:length(age.values)){
  Xs <- c(1, age.values[i], 0, 0, TRUE, TRUE*age.values[i])
  for (j in 1:1000){
    simulated[j,i] <- sum(Xs*sim.tint@coef[j,]) + rnorm(1,0,sim.tint@sigma[j])
  }
}                                                         

#Assign the 95% confidence intervals of each column in "simulated" to the vector "cfd.intervals"
#Assign the means of predicted values for each column to the vector "mean.pred"
cfd.intervals <- c()
mean.pred <- c()
for (i in 1:length(age.values)){
  cfd.intervals <- c(cfd.intervals, quantile(simulated[,i], probs = c(0.025, 0.975)))
  mean.pred <- c(mean.pred, mean(simulated[,i]))
}

#Build a table with the cfd.intervals and mean.pred of expected values of "csoa"
#Conditions: typical treated female units, target = "hicon", age.values = 20, 30, 40, 50, 60, 70, 80
mean.pred <- apply(simulated, 2, mean) #take the mean of each column in "simulated" matrix
cfd.intervals <- data.frame(t(data.frame(apply(simulated, 2, quantile, probs=c(0.025, 0.975)))))
#the function t above transposes the row generated by the innter data.frame function into a column
table <- cbind(cfd.intervals, mean.pred)
rownames(table) <- age.values
table

#Plot the confidence intervals and mean for each age
#mean
plot(age.values, table$mean.pred, ylim=c(0,100),
     xlab = "age",
     ylab = 'expected value of "csoa"',
     main = 'mean & 95% interval for expected csoa')
#confidence interval
arrows(age.values, table$X2.5., age.values, table$X97.5.,length = 0.1, angle = 90, code = 3)

###Part (b)
set.seed(18)
#the 95% interval and mean for the treatment effect, for typical female units, with
#target = “hicon”, ages = 20, 30, 40, 50, 60, 70, and 80 using simulation

#Linear regression model predicting csoa from part (a)
lm.tint <- lm(csoa ~ age + sex + target + I(tint != "no") + I(as.numeric(tint!= "no")*age), tinting)
#Generate 1000 simulations for the lm.tint model 
sim.tint <- sim(lm.tint, n.sims = 1000)
#Store the simulated values in a matrix
simulated.2 <- matrix(NA, nrow = 1000, ncol = length(age.values))

#Using "for" loop to predict treatment effect for every Female units, target = "hicon", ages = 20,30,..80
#female == 0, hicon == 0
for (i in 1:length(age.values)){
  tint.treat <- c(1, age.values[i], 0, 0, TRUE, TRUE*age.values[i])
  tint.control <- c(1, age.values[i], 0, 0, FALSE, FALSE*age.values[i])
  for (j in 1:1000){
    simulated.2[j,i] <- sum(tint.treat*sim.tint@coef[j,]) - sum(tint.control*sim.tint@coef[j,])
  }
}       
#Assign the 95% confidence intervals of each column in "simulated" to the vector "cfd.intervals.2"
#Assign the means of predicted values for each column to the vector "mean.pred.2"
cfd.intervals.2 <- c()
mean.pred.2 <- c()
for (i in 1:length(age.values)){
  cfd.intervals.2 <- c(cfd.intervals.2, quantile(simulated.2[,i], probs = c(0.025, 0.975)))
  mean.pred.2 <- c(mean.pred.2, mean(simulated.2[,i]))
}

#Build a table with the cfd.interval.2 and mean.pred.2 of the treatment effect
#Conditions: typical female units, target = "hicon", age.values = 20, 30, 40, 50, 60, 70, 80
mean.pred.2 <- apply(simulated.2, 2, mean) #take the mean of each column in simulated.2 matrix
cfd.intervals.2 <- data.frame(t(data.frame(apply(simulated.2, 2, quantile, probs=c(0.025, 0.975)))))
#the function t above transposes the row generated by the innter data.frame function into a column
table2 <- cbind(cfd.intervals.2, mean.pred.2)
rownames(table2) <- age.values
table2

#Plot the confidence intervals and mean of treatment effect for each age
#mean
plot(age.values, table2$mean.pred.2, ylim=c(-10,10),
     xlab = "age",
     ylab = 'expected treatment effect',
     main = 'mean & 95% interval of treatment effect')
#confidence interval
arrows(age.values, table2$X2.5., age.values, table2$X97.5.,length = 0.1, angle = 90, code = 3)


###QUESTION 3
#Load library and dataset
library(Matching)
data("lalonde")
#Funcion for R-squared using bootstrapping
rsquared <- function(ytrue, ypred) {
  storage <- rep(NA, 10000)
  for (i in 1:10000) {
    random = sample(1:nrow(lalonde), nrow(lalonde), replace = TRUE) #Bootstrapping among the observations in lalonde dataset 
    residual <- sum((ytrue[random]-ypred[random])^2)
    total <- sum((ytrue[random] - mean(ytrue[random]))^2)
    storage[i] <- (1-residual/total)
  }
  return(mean(storage))
}

#Apply rsquared function to "lalonde" dataset
lm.re78 = lm(re78 ~ age + educ + black + hisp + married + nodegr + treat, data = lalonde)
rsquared(lalonde$re78, lm.re78$fitted.values) #Result = 0.0459
summary(lm.re78)$r.sq #Result = 0.0479


###QUESTION 4
###Load the dataset
library(foreign)
maze <- data.frame(read.dta("mazedata1.dta"))

#Considering the "round 1" column in the maze dataset
#assign "Caste Revealed" units to treatment group 
maze.treat <- maze$round1[maze$treatment == "Caste Revealed"]
#assign not "Caste Revealed" units to control group 
maze.control <- maze$round1[maze$treatment != "Caste Revealed"]

#Start "maze.store" as a vector storing all the mean of treatment effects from 10000 bootstrap samples
maze.store <- c()
#Run 10000 bootstrap iterations to find treatment effects 
for (i in 1:10000){
  maze.store[i] <- mean(sample(maze.treat, length(maze.treat), replace = TRUE))
                    - mean(sample(maze.control, length(maze.control), replace = TRUE))
}
#Determine the 95% confidence interval for treatment effects in the "maze.store" vector 
ci.bootstrap <- quantile(maze.store, probs = c(0.025, 0.975))

#Assign 1 to "Caste Revealed" and 0 to non "Caste Revealed Units" 
maze$treatment2[maze$treatment == "Caste Revealed"] <- 1 
maze$treatment2[maze$treatment != "Caste Revealed"] <- 0

#Take "round1" as the outcome (dependent var.), "treatment2" as the predictor (independent var.)
#Build a linear regression model to predict "round1"
#Determine the 95% confidence interval for treatment effect generated from the linear model 
ci.lm <- confint(lm(round1 ~ treatment2, data = maze))

###Part (a)
#Table with 95% intervals generated through bootstrapping and through the "confint" function 
table3 <- t(data.frame(ci.bootstrap))
table3 <- rbind(table3, ci.lm[1,])
rownames(table3) <- c("bootstrap", "confint")
table3 

###Part (b)
#Build a histogram showing bootstrap sample results 
hist(maze.store,
     main = "bootstrap sample results", 
     xlab = "treatment effect",
     ylab = "frequency")


###QUESTION 5
#Load packages and data 
foo <- read.csv(url("https://tinyurl.com/yx8tqf3k"))
library(Matching)
library(boot)

#randomly set aside 2000 observations for the test set 
set.seed(12345)
test_set_rows <- sample(1:length(foo$age), 2000, replace = FALSE)

#Divide "foo" into a training set and a test set 
foo.test <- foo[test_set_rows, ]
foo.train <- foo[-test_set_rows, ]

#build logistic regression models to predict "treat" 
lm.simple <- glm(treat ~ age, data =  foo.train)
lm.complex <- glm(treat ~ .-re78, data =  foo.train)

#10-fold cross validation to estimate test-set-error (MSE)
mse.10fold.simple <- cv.glm(foo.train, lm.simple, K = 10)
mse.10fold.complex <- cv.glm(foo.train, lm.complex, K = 10)
#display the 10-fold MSEs
mse.10fold.simple$delta[1] #0.01144863
mse.10fold.complex$delta[1] #0.0100323

#LOOCV to estimate test-set-error (MSE) 
mse.loocv.simple <- cv.glm(foo.train, lm.simple)
mse.loocv.complex <- cv.glm(foo.train, lm.complex)
#display the LOOCV MSEs
mse.loocv.simple$delta[1] #0.0114497
mse.loocv.complex$delta[1] #0.01001641
#LOOCV takes much longer time than 10-fold (around 30 mins compared to a few seconds)

#Directly calculate MSE for the simple and complex model 
mse.test.simple <- mean((foo.test$treat - predict.glm(lm.simple, newdata = foo.test))^2) #0.009836669
mse.test.complex <- mean((foo.test$treat - predict.glm(lm.complex, newdata = foo.test))^2) #0.0090318

#Build a table to display the MSEs
simple <- c(mse.10fold.simple$delta[1], mse.loocv.simple$delta[1], mse.test.simple)
complex <- c(mse.10fold.complex$delta[1], mse.loocv.complex$delta[1], mse.test.complex)
table4 <- rbind(simple, complex)
colnames(table4) <- c("10-fold", "loocv", "test set MSE")
table4

#QUESTION 6
trt = matrix(NA,nrow=2,ncol=7)
ctrl = matrix(NA,nrow=2,ncol=7) 

trt[,1]=c(0, 2) #18
ctrl[,1]=c(3, 10)
trt[,2]=c(0, 3) #20
ctrl[,2]=c(2, 8)
trt[,3]=c(0, 4) #22
ctrl[,3]=c(2, 7)
trt[,4]=c(1, 3) #24
ctrl[,4]=c(2, 6)
trt[,5]=c(1, 3) #26
ctrl[,5]=c(2, 5)
trt[,6]=c(1, 3) #28
ctrl[,6]=c(2, 4)
trt[,7]=c(1, 2) #30
ctrl[,7]=c(1, 3)


c1 = rgb(red = 1, green = 0, blue = 0, alpha = 0.5) #trt
c2 = rgb(red = 0, green = 0, blue = 1, alpha = 0.5) #ctrl

plot(x = c(1:100), y = c(1:100), type = "n", xlim = c(17,31), ylim = c(0,11), cex.lab=1.2,
     main = "Alcohol Consumption - 95% Prediction Intervals", xlab = "Age",ylab = "Drinks per Week")

for (age in seq(from=18,to=30,by=2)) { 
  segments(x0 = age-0.05, y0 = trt[1, (age-18)/2+1],
           x1 = age-0.05, y1 = trt[2, (age-18)/2+1],lwd = 3,col=c1)
  
  segments(x0 = age+0.05, y0 = ctrl[1, (age-18)/2+1],
           x1 = age+0.05, y1 = ctrl[2, (age-18)/2+1],lwd = 3,col=c2)
}
legend('topright',legend=c('Treatment','Control'),fill=c(c1,c2))
mtext("https://tinyurl.com/vwxuwop", side = 1, cex = 0.5, adj = 0, padj = 10)

